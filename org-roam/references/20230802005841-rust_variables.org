:PROPERTIES:
:ID:       2f699fda-157f-48bf-aa63-a83a8ad98770
:END:
#+title: rust Variables
#+filetags:  

* Variables
Rust provides type safety via static typing. Variable bindings are immutable by default:
#+begin_src rust
fn main() {
    let x: i32 = 10;
    println!("x: {x}");
    // x = 20;
    // println!("x: {x}");
}
#+end_src
#+begin_src output
x: 10
#+end_src
*Notes*
+ Due to type inference the i32 is optional.
+ Note that since println! is a macro, x is not moved, even using the function like syntax of println!("x: {}", x)

* Type Inference
Rust will look at how the variable is used to determine the type:
#+begin_src rust
fn takes_u32(x: u32) {
    println!("u32: {x}");
}

fn takes_i8(y: i8) {
    println!("i8: {y}");
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
#+end_src
#+begin_src output
u32: 10
i8: 20
#+end_src

*Notes*
+ This slide demonstrates how the Rust compiler infers types based on constraints given by variable declarations and usages.
+ It is very important to emphasize that variables declared like this are not of some sort of dynamic “any type” that can hold any data. The machine code generated by such declaration is identical to the explicit declaration of a type. The compiler does the job for us and helps us write more concise code.

The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying the contained type, using _ as a placeholder:
#+begin_src rust
fn main() {
    let mut v = Vec::new();
    v.push((10, false));
    v.push((20, true));
    println!("v: {v:?}");

    let vv = v.iter().collect::<std::collections::HashSet<_>>();
    println!("vv: {vv:?}");
}
#+end_src

#+begin_src output
v: [(10, false), (20, true)]
vv: {(20, true), (10, false)}
#+end_src
[[https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect][collect]] relies on [[https://doc.rust-lang.org/std/iter/trait.FromIterator.html][FromIterator]], which [[https://doc.rust-lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-HashSet%3CT,+S%3E][HashSet]] implements.

* Static and Constant Variables
Static and constant variables are two different ways to create globally-scoped values that cannot be moved or reallocated during the execution of the program.

** const
Constant variables are evaluated at compile time and their values are inlined wherever they are used:
#+begin_src rust
const DIGEST_SIZE: usize = 3;
const ZERO: Option<u8> = Some(42);

fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {
    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];
    for (idx, &b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest("Hello");
    println!("Digest: {digest:?}");
}
#+end_src
#+begin_src output
Digest: [222, 254, 150]
#+end_src
According to the [[https://rust-lang.github.io/rfcs/0246-const-vs-static.html][Rust RFC Book]] these are inlined upon use.

Only functions marked const can be called at compile time to generate const values. const functions can however be called at runtime.

** static
Static variables will live during the whole execution of the program, and therefore will not move:
#+begin_src rust
static BANNER: &str = "Welcome to RustOS 3.14";

fn main() {
    println!("{BANNER}");
}
#+end_src
#+begin_src output
Welcome to RustOS 3.14
#+end_src
As noted in the [[https://rust-lang.github.io/rfcs/0246-const-vs-static.html][Rust RFC Book]], these are not inlined upon use and have an actual associated memory location. This is useful for unsafe and embedded code, and the variable lives through the entirety of the program execution. When a globally-scoped value does not have a reason to need object identity, const is generally preferred.

Because static variables are accessible from any thread, they must be Sync. Interior mutability is possible through a [[id:a0182e62-5324-42d8-a422-c01f0eb05b88][Mutex]], atomic or similar. It is also possible to have mutable statics, but they require manual synchronisation so any access to them requires unsafe code. We will look at [[id:1c6e103d-c29c-4e1b-b4cc-4ce0d3865af0][Mutable Static Variables]] in the chapter on Unsafe Rust.

*Notes*
+ Mention that const behaves semantically similar to C++’s constexpr.
+ static, on the other hand, is much more similar to a const or mutable global variable in C++.
+ static provides object identity: an address in memory and state as required by types with interior mutability such as Mutex<T>.
+ It isn’t super common that one would need a runtime evaluated constant, but it is helpful and safer than using a static.
+ thread_local data can be created with the macro std::thread_local.

Properties table:
| Property                                     | Static                            | Constant     |
|----------------------------------------------+-----------------------------------+--------------|
| Has an address in memory                     | Yes                               | No (inlined) |
| Lives for the entire duration of the program | Yes                               | No           |
| Can be mutable                               | Yes (unsafe)                      | No           |
| Evaluated at compile time                    | Yes (initialised at compile time) | Yes          |
| Inlined wherever it is used                  | No                                | Yes          |

* Scopes and Shadowing
You can shadow variables, both those from outer scopes and variables from the same scope:
#+begin_src rust
fn main() {
    let a = 10;
    println!("before: {a}");

    {
        let a = "hello";
        println!("inner scope: {a}");

        let a = true;
        println!("shadowed in inner scope: {a}");
    }

    println!("after: {a}");
}
#+end_src
#+begin_src output
before: 10
inner scope: hello
shadowed in inner scope: true
after: 10
#+end_src
*Notes*
+ Definition: Shadowing is different from mutation, because after shadowing both variable’s memory locations exist at the same time. Both are available under the same name, depending where you use it in the code.
+ A shadowing variable can have a different type.
+ Shadowing looks obscure at first, but is convenient for holding on to values after .unwrap().
+ The following code demonstrates why the compiler can’t simply reuse memory locations when shadowing an immutable variable in a scope, even if the type does not change.
#+begin_src rust
fn main() {
    let a = 1;
    let b = &a;
    let a = a + 1;
    println!("{a} {b}");
}
#+end_src
#+begin_src output
2 1
#+end_src

* Reference List
1. https://google.github.io/comprehensive-rust/basic-syntax/variables.html
