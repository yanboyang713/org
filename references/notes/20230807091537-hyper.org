:PROPERTIES:
:ID:       f7358c45-e531-4209-9a16-8150515b07e8
:END:
#+title: hyper
#+filetags: rust

* Introduction
hyper is a fast HTTP implementation written in and for [[id:a2da1c32-ba1a-4c2c-9374-1bd8896920fa][Rust]].
+ A Client for talking to web services.
+ A Server for building those web services.
+ Blazing fast* thanks to Rust.
+ High concurrency with non-blocking sockets.
+ HTTP/1 and HTTP/2 support.

* Binding a Tiny Server
In this section, we'll create a Tiny Server from scratch. We'll start with the necessary dependencies, declare a main function, and then try to build and run it.
** Adding necessary dependencies
First, we need to create a new folder where we'll add the necessary dependencies to create our first microservice. Use cargo to make a new project called hyper-microservice:
#+begin_src console
cargo new hyper-microservice
#+end_src

Open the created folder and add dependencies to your Cargo.toml file:
#+begin_src toml
[dependencies]
hyper = "0.14"
#+end_src

Full Cargo.toml
#+begin_src toml
[package]
name = "hyper-microservice"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
hyper = "0.14"
#+end_src

The single dependency is the hyper crate. The latest release of this crate is asynchronous and lies on top of the futures crate. It also uses the tokio crate for runtime, which includes the scheduler, reactor, and asynchronous sockets. Some of the necessary types of the tokio crate are re-exported in the hyper::rt module. The main purpose of hyper is to operate with the HTTP protocol, which means that the crate can support other runtimes in the future.

** The main function of the server
Let's start with the main function and add the necessary dependencies one by one, looking in detail at why we need each one. A minimal HTTP server needs the following:
+ An address to bind to
+ A server instance to handle incoming requests
+ A default handler for any request
+ A reactor (runtime) where the server instance will operate

*** Address of the server
The first thing we need is an address. A socket address consists of an IP address and a port number. We'll use IPv4 because it's widely supported.

The standard Rust library contains an IpAddr type to represent the IP address. We'll use the SocketAddr struct, which contains both the IpAddr and the u16 for the port number. We can construct the SocketAddr from a tuple of the ([u8; 4], u16) type. Add the following code to our main function:

#+begin_src rust
let addr = ([127, 0, 0, 1], 8080).into();
#+end_src

We used an implementation of the impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr trait here, which, in turn, uses impl From<[u8; 4]> for IpAddr. This lets us use the .into() method call to construct a socket address from the tuple. Similarly, we can create new SocketAddr instances with a constructor. In production applications, we will parse the socket addresses from external strings (command-line parameters or environment variables), and if no variants are set, we'll create SocketAddr from a tuple with default values.

*** Server instances

Now we can create a server instance and bind to this address:
#+begin_src rust
let builder = Server::bind(&addr);
#+end_src

The preceding line creates a *hyper::server::Server* instance with a bind constructor that actually returns Builder, not a Server instance. The Server struct implements the Future trait. It has similar role to Result, but describes a value that isn't available immediately.

*** Setting the requests handler

The Builder struct provides methods to tweak the parameters of the server created. For example, hyper's server supports both HTTP1 and HTTP2. You can use a builder value to choose either one protocol or both. In the following example, we're using builder to attach a service for handling incoming HTTP requests using the serve method:
#+begin_src rust
let server = builder.serve(|| {
    service_fn_ok(|_| {
        Response::new(Body::from("Almost microservice..."))
    })
});
#+end_src

Here, we're using the builder instance to attach a function that generates a Service instance. This function implements the *hyper::service::NewService* trait. The generated item then has to implement the *hyper::service::Service* trait. A service in a hyper crate is a function that takes a request and gives a response back. We haven't implemented this trait in this example; instead, we'll use the *service_fn_ok* function, which turns a function with suitable types into a service handler.

There are two corresponding structs: *hyper::Request* and *hyper::Response*. In the preceding code, we ignored a request argument and constructed the same response for every request. The response contains a body of static text.

*** Adding the server instance to a runtime

Since we now have a handler, we can start the server. The runtime expects a *Future* instance with the *Future<Item = (), Error = ()>* type, but the Server struct implements a Future with the *hyper::Error error* type. We can use this error to inform the user about issues, but in our example we'll just drop any error. As you might remember, the drop function expects a single argument of any type and returns a unit empty type. The Future trait uses the *map_err* method. It changes the error type using a function, which expects the original error type and returns a new one. Drop an error from the server using the following:
#+begin_src rust
let server = server.map_err(drop);
#+end_src

We now have everything we need and can start the server with the specific runtime. Use the *hyper::rt::run* function to start the server:
#+begin_src rust
hyper::rt::run(server);
#+end_src

Don't compile it yet, because we haven't imported types. Add it to the head of a source file:
#+begin_src rust
use hyper::{Body, Response, Server};
use hyper::rt::Future;
use hyper::service::service_fn_ok;
#+end_src

We need to import the different hyper types that we are using: *Server*, *Response*, and *Body*. In the final line, we're using the *service_fn_ok* function. The Future import needs special attention; it's the re-exported trait of the futures crate and it's used everywhere in the hyper crate.

*** Full Example
#+begin_src rust
use hyper::{Body, Response, Server};
use hyper::rt::Future;
use hyper::service::service_fn_ok;

fn main() {
    let addr = ([127, 0, 0, 1], 8080).into();
    let builder = Server::bind(&addr);
    let server = builder.serve(|| {
        service_fn_ok(|_| {
            Response::new(Body::from("Rust Microservice"))
        })
    });
    let server = server.map_err(drop);
    hyper::rt::run(server);
}
#+end_src

** Building and running
You can now compile the code and start the server with the following command:
#+begin_src bash
cargo run
#+end_src

Use your browser to connect to the server. Enter *http://localhost:8080/* in the browser's address bar and the browser will connect to your server and show you a page with the text you entered in the previous code.

If you want to check [[id:26296a91-d2aa-4be2-8f4e-840f36b90961][Rebuilding on changes]], Please check here.

* Handling incoming requests
We've created a server, but it isn't very useful until it can respond to real requests. In this section, we'll add handlers to the requests and use the principles of [[id:8aeb67cf-d0e4-44d2-a3d4-8e4d9f71748b][RESTful]].

** Adding a service function
In the previous section, we implemented simple services based on *service_fn_ok* functions, which expect the service function not to throw any errors. There are also *service_fn* functions, which can be used to create handlers that can return an error. These are more suitable for asynchronous [[id:4d0090f7-636c-4305-b205-3c8515da230f][Future]] results.

As we saw previously, the Future trait has two associated types: one for a successful result and one for an error. The *service_fn* function expects the result to be converted into future with the *IntoFuture* trait. You can read more about the *futures* crate and its types in the next chapter.

Let's change the previous service function into one that returns the Future instance:
#+begin_src rust
let server = builder.serve(|| service_fn(microservice_handler));
#+end_src

Then add this unimplemented service function:
#+begin_src rust
fn microservice_handler(req: Request<Body>)
    -> impl Future<Item=Response<Body>, Error=Error>
{
    unimplemented!();
}
#+end_src

Similar to the previous one, this function expects a Request, but it doesn't return a simple Response instance. Instead, it returns a future result. Since Future is a trait (which doesn't have a size), we can't return an unsized entity from the function and we have to wrap it in a Box. However, in this case, we used a brand new approach, which is the impl trait. This allows us to return an implementation of the trait by value, rather than by reference. Our future can be resolved to a *hyper::Response<Body>* item or a *hyper::Error* error type. You should import the necessary types if you've started a project from scratch and aren't using the code examples included with this book:
#+begin_src rust
use futures::{future, Future};
use hyper::{Body, Error, Method, Request, Response, Server, StatusCode};
use hyper::service::service_fn;
#+end_src

We also imported the Future trait from the futures crate. Make sure you're either using edition = "2018" in the Cargo.toml file, or importing the crates in main.rs:
#+begin_src rust
extern crate futures;
extern crate hyper;
#+end_src

* Reference List
1. https://hyper.rs/
